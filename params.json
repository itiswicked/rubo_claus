{
  "name": "RuboClaus",
  "tagline": "Ruby method pattern matching inspired by functional programming with Elixir and Erlang",
  "body": "# RuboClaus\r\n\r\nRuboClaus is an open source project that gives the Ruby developer a DSL to implement functions with multiple clauses and varying numbers of arguments on a pattern matching paradigm, inspired by functional programming in Elixir and Erlang.\r\n\r\n#### Note\r\n\r\n_RuboClaus is still in very early stage of development and thought process.  We are still treating this as a proof-of-concept and are still exploring the topic.  As such, we don't suggest you use this in any kind of production environment, without first looking at the library code and feeling comfortable with how it works.  And, if you would like to continue this thought experiment and provide feedback/suggestions/changes, we would love to hear it._\r\n\r\n### Rationale\r\n\r\nThe beauty of multiple function clauses with pattern matching is fewer conditionals and fewer lines of unnecessary defensive logic. Focus on the happy path. Control types as they come in, and handle for edge cases with catch all clauses. It does not work great for simple methods, like this:\r\n\r\nRuby:\r\n\r\n```ruby\r\ndef add(first, second)\r\n  return \"Please use numbers\" unless [first, second].all? { |obj| obj.is_a? Fixnum }\r\n  first + second\r\nend\r\n```\r\n\r\nRuby With RuboClaus:\r\n\r\n```ruby\r\ndefine_function :add do\r\n  clauses(\r\n    clause([Fixnum, Fixnum], proc { |first, second| first + second }),\r\n    catch_all(proc { \"Please use numbers\" }\r\n  )\r\nend\r\n```\r\n\r\nIt is cumbersome for problems like `add`--in which case we don't recommend using it. But as soon as we add complexity that depends on parameter arity or type, we can see how RuboClaus makes our code more extendible and maintainable. For example:\r\n\r\nRuby:\r\n\r\n```ruby\r\ndef handle_response(status, has_body, is_chunked)\r\n  if status == 200 && has_body && is_chunked\r\n    # ...\r\n  else\r\n    if status == 200 && has_body && !is_chunked\r\n      # ...\r\n    else\r\n      if status == 200 && !has_body\r\n        # ...\r\n      else\r\n        # ...\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nRuby with RuboClaus:\r\n\r\n```ruby\r\ndefine_function :handle_response do\r\n  clauses(\r\n    clause([200, true, true], proc { |status, has_body, is_chunked| ... }),\r\n    clause([200, true, false], proc { |status, has_body, is_chunked| ... }),\r\n    clause([200, false], proc { |status, has_body| ... }),\r\n    catch_all(proc { return_error })\r\n  )\r\nend\r\n```\r\n[Credit](https://www.reddit.com/r/elixir/comments/34jyto/what_are_the_benefits_of_pattern_matching_as/cqve33n)\r\n\r\nTo learn more about this style of programming read about [function overloading](https://en.wikipedia.org/wiki/Function_overloading) and [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching).\r\n\r\n## Usage\r\n\r\nBelow are the public API methods and their associated arguments.\r\n\r\n* `define_function`\r\n\t* Symbol - name of the method to define\r\n\t* Block - a single block with a `clauses` method call\r\n* `clauses`\r\n\t* N number of `clause` method calls and/or a single `catch_all` method call\r\n* `clause`\r\n\t* Array - list of arguments to pattern match against\r\n\t* Proc - method body to execute when this method is matched and executed\r\n* `catch_all`\r\n\t* Proc - method body that will be executed if the arguments do not match any of the `clause` patterns defined\r\n\r\n### Clause pattern arguments\r\n\r\nThe first argument to the `clause` method is an array of pattern match options.  This array can vary in length, and values depending on your pattern match case.\r\n\r\nYou can match against specific values:\r\n\r\n```ruby\r\nclause([\"foo\"], proc {...})\r\nclause([42], proc {...})\r\nclause([\"Hello\", :darth_vader], proc {...})\r\n```\r\n\r\nYou can match against specifc argument types:\r\n\r\n```ruby\r\nclause([String], proc {...})\r\nclause([Fixnum], proc {...})\r\nclause([String, Symbol], proc {...})\r\n```\r\n\r\nYou can match against specific values and types:\r\n\r\n```ruby\r\nclause([\"Hello\", String], proc {...})\r\nclause([42, Fixnum], proc {...})\r\nclause([String, :darth_vader], proc {...})\r\n```\r\n\r\nYou also can match against any value or type if you don't have a specific requirement for an argument by using the `:any` symbol.\r\n\r\n```ruby\r\nclause([\"Hello\", :any], proc {...})\r\nclause([:any], proc {...})\r\nclause([42, :any], proc {...})\r\n```\r\n\r\n\r\n\r\n### Examples\r\n\r\nPlease see the [examples directory](https://github.com/mojotech/rubo_claus/tree/master/examples) for various example use cases.  Most examples include direct comparisons of the Ruby code to a similar implementation in Elixir.\r\n\r\n## Development\r\n\r\nDon't introduce unneeded external dependencies.\r\n\r\nNothing else special to note for development.  Just add tests associated to any code changes and make sure they pass.\r\n\r\n## TODO\r\n\r\n- [ ] Rename public API methods? `define_function` is awkward since Ruby uses the term `method` instead of `function`\r\n- [ ] Add Benchmarks to see performance implications\r\n- [ ] Support private clauses to enforce a single entry point to a defined function\r\n\r\n---\r\n\r\n[![Build Status](https://travis-ci.org/mojotech/rubo_claus.svg?branch=master)](https://travis-ci.org/mojotech/rubo_claus)\r\n[![contributions welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)](https://github.com/dwyl/esta/issues)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}